import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import SearchDriver from "../SearchDriver";
var suggestions = {
  documents: [{
    suggestion: "carlsbad"
  }, {
    suggestion: "carlsbad caverns"
  }, {
    suggestion: "carolina"
  }]
};
var searchResponse = {
  totalResults: 1000,
  totalPages: 100,
  requestId: "12345",
  facets: {},
  results: [{}, {}]
};
var autocompleteSearchResponse = {
  requestId: "6789",
  results: [{}, {}]
};
export function getMockApiConnector() {
  return {
    onAutocomplete: jest.fn().mockReturnValue({
      then: function then(cb) {
        return cb({
          autocompletedResults: autocompleteSearchResponse.results,
          autocompletedResultsRequestId: autocompleteSearchResponse.requestId,
          autocompletedSuggestions: suggestions
        });
      }
    }),
    onSearch: jest.fn().mockReturnValue({
      then: function then(cb) {
        return cb(searchResponse);
      }
    }),
    onResultClick: jest.fn().mockReturnValue({
      then: function then() {}
    }),
    onAutocompleteResultClick: jest.fn().mockReturnValue({
      then: function then() {}
    })
  };
}
export function setupDriver() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      mockSearchResponse = _ref.mockSearchResponse,
      mockApiConnector = _ref.mockApiConnector,
      rest = _objectWithoutProperties(_ref, ["mockSearchResponse", "mockApiConnector"]);

  mockApiConnector = mockApiConnector || getMockApiConnector();

  if (mockSearchResponse) {
    mockApiConnector.onSearch = jest.fn().mockReturnValue({
      then: function then(cb) {
        return cb(mockSearchResponse);
      }
    });
  }

  var driver = new SearchDriver(_objectSpread(_objectSpread({
    apiConnector: mockApiConnector
  }, rest), {}, {
    // We don't want to deal with async in our tests, so pass 0 so URL state
    // pushes happen synchronously
    urlPushDebounceLength: 0
  }));
  var updatedStateAfterAction = {};
  driver.subscribeToStateChanges(function (newState) {
    updatedStateAfterAction.state = newState;
  });
  jest.runAllTimers();
  return {
    stateAfterCreation: driver.getState(),
    driver: driver,
    updatedStateAfterAction: updatedStateAfterAction,
    mockApiConnector: mockApiConnector
  };
}
export function doesStateHaveResponseData(response) {
  var requestId = response.requestId,
      results = response.results,
      totalPages = response.totalPages,
      totalResults = response.totalResults,
      wasSearched = response.wasSearched;
  return !!results && results.length && !!requestId && totalPages > 0 && totalResults > 0 && !!wasSearched;
}
export function getSearchCalls(mockApiConnector) {
  return mockApiConnector.onSearch.mock.calls;
}
export function getAutocompleteCalls(mockApiConnector) {
  return mockApiConnector.onAutocomplete.mock.calls;
}
export function getClickCalls(mockApiConnector) {
  return mockApiConnector.onResultClick.mock.calls;
}
export function getAutocompleteClickCalls(mockApiConnector) {
  return mockApiConnector.onAutocompleteResultClick.mock.calls;
}
/**
 * Returns a promise that resolves after the current event loop.
 *
 * Useful for writing `await waitATick()` to wait for a promise to resolve.
 */

export function waitATick() {
  var promiseResolve;
  var promise = new Promise(function (resolve) {
    return promiseResolve = resolve;
  });
  setTimeout(function () {
    return promiseResolve();
  });
  jest.runAllTimers();
  return promise;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy90ZXN0L2hlbHBlcnMuanMiXSwibmFtZXMiOlsiU2VhcmNoRHJpdmVyIiwic3VnZ2VzdGlvbnMiLCJkb2N1bWVudHMiLCJzdWdnZXN0aW9uIiwic2VhcmNoUmVzcG9uc2UiLCJ0b3RhbFJlc3VsdHMiLCJ0b3RhbFBhZ2VzIiwicmVxdWVzdElkIiwiZmFjZXRzIiwicmVzdWx0cyIsImF1dG9jb21wbGV0ZVNlYXJjaFJlc3BvbnNlIiwiZ2V0TW9ja0FwaUNvbm5lY3RvciIsIm9uQXV0b2NvbXBsZXRlIiwiamVzdCIsImZuIiwibW9ja1JldHVyblZhbHVlIiwidGhlbiIsImNiIiwiYXV0b2NvbXBsZXRlZFJlc3VsdHMiLCJhdXRvY29tcGxldGVkUmVzdWx0c1JlcXVlc3RJZCIsImF1dG9jb21wbGV0ZWRTdWdnZXN0aW9ucyIsIm9uU2VhcmNoIiwib25SZXN1bHRDbGljayIsIm9uQXV0b2NvbXBsZXRlUmVzdWx0Q2xpY2siLCJzZXR1cERyaXZlciIsIm1vY2tTZWFyY2hSZXNwb25zZSIsIm1vY2tBcGlDb25uZWN0b3IiLCJyZXN0IiwiZHJpdmVyIiwiYXBpQ29ubmVjdG9yIiwidXJsUHVzaERlYm91bmNlTGVuZ3RoIiwidXBkYXRlZFN0YXRlQWZ0ZXJBY3Rpb24iLCJzdWJzY3JpYmVUb1N0YXRlQ2hhbmdlcyIsIm5ld1N0YXRlIiwic3RhdGUiLCJydW5BbGxUaW1lcnMiLCJzdGF0ZUFmdGVyQ3JlYXRpb24iLCJnZXRTdGF0ZSIsImRvZXNTdGF0ZUhhdmVSZXNwb25zZURhdGEiLCJyZXNwb25zZSIsIndhc1NlYXJjaGVkIiwibGVuZ3RoIiwiZ2V0U2VhcmNoQ2FsbHMiLCJtb2NrIiwiY2FsbHMiLCJnZXRBdXRvY29tcGxldGVDYWxscyIsImdldENsaWNrQ2FsbHMiLCJnZXRBdXRvY29tcGxldGVDbGlja0NhbGxzIiwid2FpdEFUaWNrIiwicHJvbWlzZVJlc29sdmUiLCJwcm9taXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0Il0s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QztBQUNEO0FBRUQsT0FBTyxTQUFTRyx5QkFBVCxDQUFtQ3JCLGdCQUFuQyxFQUFxRDtBQUMxRCxTQUFPQSxnQkFBZ0IsQ0FBQ0gseUJBQWpCLENBQTJDb0IsSUFBM0MsQ0FBZ0RDLEtBQXZEO0FBQ0Q7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLE9BQU8sU0FBU0ksU0FBVCxHQUFxQjtBQUMxQixNQUFJQyxjQUFKO0FBQ0EsTUFBTUMsT0FBTyxHQUFHLElBQUlDLE9BQUosQ0FBWSxVQUFBQyxPQUFPO0FBQUEsV0FBS0gsY0FBYyxHQUFHRyxPQUF0QjtBQUFBLEdBQW5CLENBQWhCO0FBQ0FDLEVBQUFBLFVBQVUsQ0FBQztBQUFBLFdBQU1KLGNBQWMsRUFBcEI7QUFBQSxHQUFELENBQVY7QUFDQXBDLEVBQUFBLElBQUksQ0FBQ3NCLFlBQUw7QUFDQSxTQUFPZSxPQUFQO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgU2VhcmNoRHJpdmVyIGZyb20gXCIuLi9TZWFyY2hEcml2ZXJcIjtcblxuY29uc3Qgc3VnZ2VzdGlvbnMgPSB7XG4gIGRvY3VtZW50czogW1xuICAgIHtcbiAgICAgIHN1Z2dlc3Rpb246IFwiY2FybHNiYWRcIlxuICAgIH0sXG4gICAge1xuICAgICAgc3VnZ2VzdGlvbjogXCJjYXJsc2JhZCBjYXZlcm5zXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIHN1Z2dlc3Rpb246IFwiY2Fyb2xpbmFcIlxuICAgIH1cbiAgXVxufTtcblxuY29uc3Qgc2VhcmNoUmVzcG9uc2UgPSB7XG4gIHRvdGFsUmVzdWx0czogMTAwMCxcbiAgdG90YWxQYWdlczogMTAwLFxuICByZXF1ZXN0SWQ6IFwiMTIzNDVcIixcbiAgZmFjZXRzOiB7fSxcbiAgcmVzdWx0czogW3t9LCB7fV1cbn07XG5cbmNvbnN0IGF1dG9jb21wbGV0ZVNlYXJjaFJlc3BvbnNlID0ge1xuICByZXF1ZXN0SWQ6IFwiNjc4OVwiLFxuICByZXN1bHRzOiBbe30sIHt9XVxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldE1vY2tBcGlDb25uZWN0b3IoKSB7XG4gIHJldHVybiB7XG4gICAgb25BdXRvY29tcGxldGU6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgdGhlbjogY2IgPT5cbiAgICAgICAgY2Ioe1xuICAgICAgICAgIGF1dG9jb21wbGV0ZWRSZXN1bHRzOiBhdXRvY29tcGxldGVTZWFyY2hSZXNwb25zZS5yZXN1bHRzLFxuICAgICAgICAgIGF1dG9jb21wbGV0ZWRSZXN1bHRzUmVxdWVzdElkOiBhdXRvY29tcGxldGVTZWFyY2hSZXNwb25zZS5yZXF1ZXN0SWQsXG4gICAgICAgICAgYXV0b2NvbXBsZXRlZFN1Z2dlc3Rpb25zOiBzdWdnZXN0aW9uc1xuICAgICAgICB9KVxuICAgIH0pLFxuICAgIG9uU2VhcmNoOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgdGhlbjogY2IgPT4gY2Ioc2VhcmNoUmVzcG9uc2UpIH0pLFxuICAgIG9uUmVzdWx0Q2xpY2s6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyB0aGVuOiAoKSA9PiB7fSB9KSxcbiAgICBvbkF1dG9jb21wbGV0ZVJlc3VsdENsaWNrOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgdGhlbjogKCkgPT4ge30gfSlcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldHVwRHJpdmVyKHtcbiAgbW9ja1NlYXJjaFJlc3BvbnNlLFxuICBtb2NrQXBpQ29ubmVjdG9yLFxuICAuLi5yZXN0XG59ID0ge30pIHtcbiAgbW9ja0FwaUNvbm5lY3RvciA9IG1vY2tBcGlDb25uZWN0b3IgfHwgZ2V0TW9ja0FwaUNvbm5lY3RvcigpO1xuXG4gIGlmIChtb2NrU2VhcmNoUmVzcG9uc2UpIHtcbiAgICBtb2NrQXBpQ29ubmVjdG9yLm9uU2VhcmNoID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICB0aGVuOiBjYiA9PiBjYihtb2NrU2VhcmNoUmVzcG9uc2UpXG4gICAgfSk7XG4gIH1cblxuICBjb25zdCBkcml2ZXIgPSBuZXcgU2VhcmNoRHJpdmVyKHtcbiAgICBhcGlDb25uZWN0b3I6IG1vY2tBcGlDb25uZWN0b3IsXG4gICAgLy8gUGFzcywgZS5nLiwgaW5pdGlhbFN0YXRlIGFuZCBhbGwgb3RoZXIgY29uZmlnc1xuICAgIC4uLnJlc3QsXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBkZWFsIHdpdGggYXN5bmMgaW4gb3VyIHRlc3RzLCBzbyBwYXNzIDAgc28gVVJMIHN0YXRlXG4gICAgLy8gcHVzaGVzIGhhcHBlbiBzeW5jaHJvbm91c2x5XG4gICAgdXJsUHVzaERlYm91bmNlTGVuZ3RoOiAwXG4gIH0pO1xuXG4gIGNvbnN0IHVwZGF0ZWRTdGF0ZUFmdGVyQWN0aW9uID0ge307XG4gIGRyaXZlci5zdWJzY3JpYmVUb1N0YXRlQ2hhbmdlcyhuZXdTdGF0ZSA9PiB7XG4gICAgdXBkYXRlZFN0YXRlQWZ0ZXJBY3Rpb24uc3RhdGUgPSBuZXdTdGF0ZTtcbiAgfSk7XG5cbiAgamVzdC5ydW5BbGxUaW1lcnMoKTtcblxuICByZXR1cm4ge1xuICAgIHN0YXRlQWZ0ZXJDcmVhdGlvbjogZHJpdmVyLmdldFN0YXRlKCksXG4gICAgZHJpdmVyLFxuICAgIHVwZGF0ZWRTdGF0ZUFmdGVyQWN0aW9uLFxuICAgIG1vY2tBcGlDb25uZWN0b3JcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRvZXNTdGF0ZUhhdmVSZXNwb25zZURhdGEocmVzcG9uc2UpIHtcbiAgY29uc3Qge1xuICAgIHJlcXVlc3RJZCxcbiAgICByZXN1bHRzLFxuICAgIHRvdGFsUGFnZXMsXG4gICAgdG90YWxSZXN1bHRzLFxuICAgIHdhc1NlYXJjaGVkXG4gIH0gPSByZXNwb25zZTtcbiAgcmV0dXJuIChcbiAgICAhIXJlc3VsdHMgJiZcbiAgICByZXN1bHRzLmxlbmd0aCAmJlxuICAgICEhcmVxdWVzdElkICYmXG4gICAgdG90YWxQYWdlcyA+IDAgJiZcbiAgICB0b3RhbFJlc3VsdHMgPiAwICYmXG4gICAgISF3YXNTZWFyY2hlZFxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2VhcmNoQ2FsbHMobW9ja0FwaUNvbm5lY3Rvcikge1xuICByZXR1cm4gbW9ja0FwaUNvbm5lY3Rvci5vblNlYXJjaC5tb2NrLmNhbGxzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXV0b2NvbXBsZXRlQ2FsbHMobW9ja0FwaUNvbm5lY3Rvcikge1xuICByZXR1cm4gbW9ja0FwaUNvbm5lY3Rvci5vbkF1dG9jb21wbGV0ZS5tb2NrLmNhbGxzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2xpY2tDYWxscyhtb2NrQXBpQ29ubmVjdG9yKSB7XG4gIHJldHVybiBtb2NrQXBpQ29ubmVjdG9yLm9uUmVzdWx0Q2xpY2subW9jay5jYWxscztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEF1dG9jb21wbGV0ZUNsaWNrQ2FsbHMobW9ja0FwaUNvbm5lY3Rvcikge1xuICByZXR1cm4gbW9ja0FwaUNvbm5lY3Rvci5vbkF1dG9jb21wbGV0ZVJlc3VsdENsaWNrLm1vY2suY2FsbHM7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyBhZnRlciB0aGUgY3VycmVudCBldmVudCBsb29wLlxuICpcbiAqIFVzZWZ1bCBmb3Igd3JpdGluZyBgYXdhaXQgd2FpdEFUaWNrKClgIHRvIHdhaXQgZm9yIGEgcHJvbWlzZSB0byByZXNvbHZlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gd2FpdEFUaWNrKCkge1xuICBsZXQgcHJvbWlzZVJlc29sdmU7XG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IChwcm9taXNlUmVzb2x2ZSA9IHJlc29sdmUpKTtcbiAgc2V0VGltZW91dCgoKSA9PiBwcm9taXNlUmVzb2x2ZSgpKTtcbiAgamVzdC5ydW5BbGxUaW1lcnMoKTtcbiAgcmV0dXJuIHByb21pc2U7XG59XG4iXX0=